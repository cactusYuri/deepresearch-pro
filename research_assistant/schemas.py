from pydantic import BaseModel, Field, HttpUrl
from typing import List, Optional, Dict, Any
import datetime

# --- API Request Schemas ---

class SubmitTaskRequest(BaseModel):
    topic: str = Field(..., description="User's research topic in natural language.")
    selected_conferences: Optional[List[str]] = Field(None, description="List of top conferences user is interested in (e.g., ['NeurIPS', 'CVPR']). If None, use all from config.")

class ConfirmTaskRequest(BaseModel):
    user_confirmation: str = Field(..., description="User's response to the clarification questions or confirmation to proceed.")

# --- API Response Schemas ---

class TaskInfo(BaseModel):
    task_id: str
    status: str = "pending" # pending, awaiting_confirmation, processing, completed, failed
    message: Optional[str] = None
    created_at: datetime.datetime = Field(default_factory=datetime.datetime.utcnow)
    topic: str
    selected_conferences: Optional[List[str]]
    clarification_prompt: Optional[str] = Field(None, description="Questions or options generated by the LLM for user confirmation.")
    final_queries: Optional[List[str]] = Field(None, description="Final search queries generated after confirmation.")

class SubmitTaskResponse(BaseModel):
    task_id: str
    message: str = "Task submitted successfully. Awaiting confirmation if needed."
    clarification_prompt: Optional[str] = None # Return the prompt immediately if generated
    status: str # Return the initial status (pending or awaiting_confirmation)

class TaskStatusResponse(TaskInfo):
    pass # Inherits all fields from TaskInfo

class PaperMetadata(BaseModel):
    title: Optional[str] = None
    authors: List[str] = []
    abstract: Optional[str] = None
    url: Optional[str] = None
    source: Optional[str] = None # e.g., "NeurIPS 2024", "arXiv"
    year: Optional[int] = None
    doi: Optional[str] = None
    arxiv_id: Optional[str] = None
    is_top_conference: bool = False
    # relevance_score: Optional[float] = None # Future: LLM based relevance

    # 用于去重的唯一标识符
    def get_unique_id(self) -> Optional[str]:
        if self.doi:
            return f"doi:{self.doi.lower()}"
        if self.arxiv_id:
            # ArXiv ID 可能有版本号，先简单处理
            return f"arxiv:{self.arxiv_id.split('v')[0].lower()}"
        if self.title and self.authors:
            # 简单组合标题和第一作者姓氏作为备用 ID
            first_author_last_name = self.authors[0].split()[-1].lower() if self.authors else "unknown"
            return f"title:{self.title.lower()}_{first_author_last_name}"
        return None
        
    def dict(self, **kwargs):
        """重写dict方法，确保HttpUrl类型正确序列化为字符串"""
        d = super().dict(**kwargs)
        # 将HttpUrl类型转换为字符串
        if self.url is not None:
            d['url'] = str(self.url)
        return d

class TaskResultResponse(TaskInfo):
    results: Optional[Dict[str, List[PaperMetadata]]] = None # Key: query string, Value: list of papers

# --- Internal Data Structures ---

class Task(TaskInfo):
    results_path: Optional[str] = None # Path to the results folder for this task
    user_confirmation_response: Optional[str] = Field(None, description="User's actual response to the clarification.")
    # Internal state can be added here if needed using Pydantic's private attributes or Config class
    class Config:
        arbitrary_types_allowed = True # Allow Path objects if needed later

# 全局任务存储 (简单内存实现, 生产环境建议用 Redis 或数据库)
# Key: task_id, Value: Task object
task_storage: Dict[str, Task] = {} 